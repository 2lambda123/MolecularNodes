import numpy as np
import biotite.structure as struc
import biotite.structure.io.pdbx as pdbx
from . import load
from . import tools

world_scale = 0.01

def fix_file_cif(file, new_file_name):
    f = open(file_path)
    lines = f.readlines()
    f.close()
    
    for i in range(len(lines)):
        line = lines[i]
        if line.startswith('ATOM'):
            split = line.split()
            split[18] = split[6]
            split[17] = split[16]
            split[16] = split[8]
            new_line = " ".join(split)
            # print(new_line)
            new_lines[i] = new_line + "\n"
    f = open(new_file_name, "w")
    for line in new_lines:
        f.write(line)
    f.close()

def add_each_chain(mol, n_chains = 3):
    mol = mol[0]
    
    coll_mn = tools.coll_mn()
    coll_models = bpy.data.collections.new(mol_object.name + "_frames")
    collection.children.link(coll_models)
    
    chains_unique = np.unique(mol.chain_id)
    chain_number = np.fromiter(
        map(
            lambda x: np.searchsorted(chains_unique, x), 
            mol.chain_id
        ), 
        dtype=int
    )
    
    if len(chains_unique) < n_chains:
        n_chains = len(chains_unique)
    
    for i in range(n_chains):
        mol_sub = mol[chain_number == i]
        mol_name = str(chains_unique[i])
        
        load.create_molecule(
            mol_array = mol_sub, 
            mol_name = mol_name, 
            collection = coll_models
            )
        

def create_cell(transforms):
    trans_positions = np.array([trans[1] for trans in transforms.values()])
    rot0 = np.array([rot[0][0:1, :][0] for rot in transforms.values()])
    rot1 = np.array([rot[0][1:2, :][0] for rot in transforms.values()])
    rot2 = np.array([rot[0][2:3, :][0] for rot in transforms.values()])

    cell = load.create_object('CellPack', tools.coll_mn(), trans_positions * world_scale)

    rots = [rot1, rot2, rot3]

    for i in range(3):
        rot = "rot" + str(i)
        att = cell.data.attributes.get(rot)
        if not att:
            cell.data.atttributes.new(rot, 'FLOAT_VECTOR', 'POINT')

        att.data.foreach_set('vector', [value for value in rot[i].reshape((len(rot[i]) * 3))])
    
